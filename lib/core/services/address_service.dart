import 'package:get/get.dart';
import 'package:geolocator/geolocator.dart';
import 'package:geocoding/geocoding.dart';
import 'package:stronger_muscles/data/models/address_model.dart';
import 'package:stronger_muscles/core/services/auth_service.dart';

class AddressService extends GetxService {
  final AuthService _authService = Get.find<AuthService>();

  // --- Address Management via AuthService ---

  Future<List<AddressModel>> getAddresses() async {
    try {
      final user = await _authService.getCurrentUser();
      return user?.addresses ?? [];
    } catch (e) {
      print('Error fetching addresses: $e');
      return [];
    }
  }

  Future<AddressModel> createAddress(AddressModel address) async {
    try {
      final user = await _authService.getCurrentUser();
      if (user == null) throw Exception('User not found');

      List<AddressModel> currentAddresses = List.from(user.addresses ?? []);
      
      // Assign a temporary ID if not provided (backend usually handles this, but since we are sending the whole list...)
      // Effectively we adding to the list and sending the update.
      // If the backend expects us to create an address via a separate API then link it, this approach is wrong.
      // BUT the user specifically asked "I want to enter the user address in the user model correctly".
      // So we assume the backend "updateProfile" accepts the list of addresses and replaces them or updates them.
      
      // Let's ensure the ID is handled. If it's a new address it might need 0 or null.
      // The model has 'required int id'. We might need to generate a temp one or depend on backend response.
      // For now, let's assume we can generate a random one or the backend ignores it for new items.
      final newAddress = address.copyWith(id: address.id == 0 ? DateTime.now().millisecondsSinceEpoch : address.id);
      
      currentAddresses.add(newAddress);

      final updatedUser = await _authService.updateProfile(addresses: currentAddresses);
      
      // Return the added address (or the one from updatedUser if we could identify it)
      // Since we don't know which one it is exactly without an ID generated by backend, 
      // we'll return the one we created or the last one from the list.
      return updatedUser.addresses?.last ?? newAddress;
    } catch (e) {
      print('Error creating address: $e');
      rethrow;
    }
  }

  Future<AddressModel> updateAddress(int id, AddressModel address) async {
    try {
      final user = await _authService.getCurrentUser();
      if (user == null) throw Exception('User not found');

      List<AddressModel> currentAddresses = List.from(user.addresses ?? []);
      
      final index = currentAddresses.indexWhere((a) => a.id == id);
      if (index != -1) {
        currentAddresses[index] = address;
        final updatedUser = await _authService.updateProfile(addresses: currentAddresses);
         return updatedUser.addresses?.firstWhere((a) => a.id == id, orElse: () => address) ?? address;
      } else {
        throw Exception('Address not found');
      }
    } catch (e) {
      print('Error updating address: $e');
      rethrow;
    }
  }

  Future<void> deleteAddress(int id) async {
    try {
      final user = await _authService.getCurrentUser();
      if (user == null) throw Exception('User not found');

      List<AddressModel> currentAddresses = List.from(user.addresses ?? []);
      currentAddresses.removeWhere((a) => a.id == id);

      await _authService.updateProfile(addresses: currentAddresses);
    } catch (e) {
      print('Error deleting address: $e');
      rethrow;
    }
  }

  // --- Geolocation Methods ---

  Future<Position> getCurrentPosition() async {
    bool serviceEnabled;
    LocationPermission permission;

    serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      return Future.error('Location services are disabled.');
    }

    permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
      if (permission == LocationPermission.denied) {
        return Future.error('Location permissions are denied');
      }
    }
    
    if (permission == LocationPermission.deniedForever) {
      return Future.error(
        'Location permissions are permanently denied, we cannot request permissions.');
    } 

    return await Geolocator.getCurrentPosition();
  }

  Future<Placemark?> getAddressFromCoordinates(double latitude, double longitude) async {
    try {
      List<Placemark> placemarks = await placemarkFromCoordinates(latitude, longitude);
      if (placemarks.isNotEmpty) {
        return placemarks.first;
      }
      return null;
    } catch (e) {
      print('Error getting address from coordinates: $e');
      return null;
    }
  }
}
